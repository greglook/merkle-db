<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title># Random Access</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Merkle-db</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="api.html"><div class="inner"><span>## Connection Operations</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span># Database Roots</span></div></a></li><li class="depth-1  current"><a href="usage.html"><div class="inner"><span># Random Access</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>merkle-db</span></div></div></li><li class="depth-2 branch"><a href="merkle-db.bloom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bloom</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.partition.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>partition</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.patch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>patch</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-2"><a href="merkle-db.tablet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tablet</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#usage-patterns" name="usage-patterns"></a>Usage Patterns</h1>
<p>This document details how to use MerkleDB to satisfy various usage patterns.</p>
<h2><a href="#random-access" name="random-access"></a>Random Access</h2>
<p>For basic usage, the database records can be accessed directly using the high-level record operations. This will generally not be as performant, but is sufficient for simple use-cases.</p>
<h2><a href="#bulk-read" name="bulk-read"></a>Bulk Read</h2>
<p>Partitions provide a natural grain to parallelize reads over. Either the whole table or the partitions covering a specific range of keys can be selected for querying and read in parallel. Each partition and the corresponding tablets only need to be read by a single job.</p>
<p>Choosing field families which align with the types of queries done over the data will improve IO efficiency, because only the required tablets will be loaded for each partition.</p>
<h2><a href="#bulk-update" name="bulk-update"></a>Bulk Update</h2>
<p>Doing large bulk writes with unsorted record keys will generally update most of the partitions within a table. In this case, using the high-level write operation will generally not be very efficient. Instead, updates may be done in parallel by applying the following method to each table:</p>
<ol>
  <li>List the partitions in the table to be updated.</li>
  <li>Divide up the record keyspace into ranges matching the partitions.</li>
  <li>Group the record updates into batches based on which partition’s range they  fall into.</li>
  <li>In parallel, process each batch of updates and existing partition to produce  a sequence of output partitions (for example, there may be more than one if  the partition exceeds the size limit and splits). Write the updated tablets  and new partitions to the backing block store.</li>
  <li>Build a new index tree over the new set of partitions and update the table.</li>
</ol>
<p>Choosing field families which align with the types of writes to the table will reduce IO and improve storage efficiency, because the existing tablets can be re-used from the current version.</p>
<h2><a href="#time-series-data" name="time-series-data"></a>Time-Series Data</h2>
<p>This is also known as “append-only” or “log-style” data. Writes only ever add new data to the table, and deletions are generally rare and occur on large blocks of old data (aging).</p>
<p>In order to support this pattern, the record keys must be monotonically increasing. This way, new batches of data can be written as a new partition, whose record keys are all greater than any keys already in the table. The new partition is appended to the sequence of partitions and a new index tree is built to incorporate it.</p>
<p>For reads from time-series data, it is desirable to find out only “new” information to enable incremental processing. Because partitions are immutable and shared broadly, a simple hash id comparison can be used to detect partitions added or changed between two versions. The fact that partitions don’t overlap makes it safe for consumers to assume all new partitions are new data.</p>
<h2><a href="#logical-record-versions" name="logical-record-versions"></a>Logical Record Versions</h2>
<p>Logical versions make it possible to write a record with version <em>v</em>, then later try to write version <em>v-1</em> and wind up with the database still reflecting version <em>v</em>. This makes writes idempotent, guaranteeing the database always reflects the latest version of a record.</p>
<p>Logical versions can be implemented with a custom <code>merge-record</code> function on inserts. The function should use a version field on the records to determine which whole data map to keep when writes occur.</p>
<h2><a href="#transaction-metadata" name="transaction-metadata"></a>Transaction Metadata</h2>
<p>Reified transactions can be implemented by adding custom record fields on write and utilizing the database-level user metadata to store information about the transactions. Such metadata might include the timestamp, author, commit message, etc.</p>
<p><strong>TODO:</strong> It might be good to formalize this with some kind of middleware.</p></div></div></div></body></html>