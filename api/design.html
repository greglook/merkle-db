<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Structural Design</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Merkle-db</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="api.html"><div class="inner"><span>Client API</span></div></a></li><li class="depth-1  current"><a href="design.html"><div class="inner"><span>Structural Design</span></div></a></li><li class="depth-1 "><a href="usage.html"><div class="inner"><span>Usage Patterns</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>merkle-db</span></div></div></li><li class="depth-2 branch"><a href="merkle-db.bloom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bloom</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.partition.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>partition</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.patch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>patch</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-2"><a href="merkle-db.tablet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tablet</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#structural-design" name="structural-design"></a>Structural Design</h1>
<p>A database is stored as a <em>merkle tree</em>, which is a type of <a href="https://github.com/greglook/merkledag-core">merkle DAG</a> structure. Each node in the tree is an immutable <a href="https://github.com/greglook/blocks">content-addressed block</a> identified by a <a href="https://github.com/multiformats/clj-multihash">cryptographic hash</a> of its byte content. The data in each block is serialized with a <em>codec</em> and wrapped in <a href="https://github.com/multiformats/clj-multicodec">multicodec headers</a> to support format versioning and feature evolution. Initial versions will use the <a href="https://github.com/greglook/clj-cbor">CBOR</a> format for node data and Snappy for compression.</p>
<p><img src="doc/images/db-data-structure.jpg" alt="MerkleDB database structure" /></p>
<p>Within a node, references to other nodes are represented with <em>merkle links</em>, which combine a multihash target with an optional name and the recursive size of the referenced block. These links are themselves part of the hashed content of the node, so a change to any part of the tree must propagate up to the root node. The entire immutable tree of data at a specific version can therefore be identified by the hash of the database root node.</p>
<h2><a href="#database-roots" name="database-roots"></a>Database Roots</h2>
<p>The root of a database is a block which contains database-wide settings and maps table names to <em>table root nodes</em>.</p>
<pre><code class="clojure">{:data/type :merkle-db/database
 :merkle-db.db/tables {String MerkleLink}
 :time/updated-at Instant
 ,,,}
</code></pre>
<p>Database roots may contain additional arbitrary entries to support user-set metadata on the table. For example, this could be used to add a <code>:data/description</code> value to the database.</p>
<h2><a href="#table-roots" name="table-roots"></a>Table Roots</h2>
<p>A table root is a node which contains table-wide settings and links to the tree of record data. The records in a table are grouped into <em>partitions</em>, which each contain the data for a contiguous, non-overlapping range of record keys.</p>
<pre><code class="clojure">{:data/type :merkle-db/table-root
 :merkle-db.data/count Long
 :merkle-db.data/families {Keyword #{field-key}}
 :merkle-db.key/lexicoder Keyword
 :merkle-db.index/branching-factor Long  ; e.g. 256 children
 :merkle-db.partition/limit Long         ; e.g. 100,000 records
 :merkle-db.table/data MerkleLink
 :merkle-db.table/patch MerkleLink
 :time/updated-at Instant
 ,,,}
</code></pre>
<p>Similar to the database root, tables may also contain additional entries to attach user-specified metadata to them.</p>
<h2><a href="#data-index-trees" name="data-index-trees"></a>Data Index Trees</h2>
<p>Index trees are modeled after a <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a> and contain both internal index nodes and leaf partitions. Records in the tree are sorted by their <em>id key</em>, which uniquely identifies each record within the table. Record keys are just bytes, allowing for pluggable key serialization formats.</p>
<p>The tree nodes contain a count of the records under them, so the index is also an <a href="https://en.wikipedia.org/wiki/Order_statistic_tree">order statistic tree</a>. A similar metric for the linked block sizes allows for quick recursive data sizing.</p>
<pre><code class="clojure">{:data/type :merkle-db/index
 :merkle-db.data/count Long
 :merkle-db.index/height Long
 :merkle-db.index/keys
 [key-bytes-A  ; encoded key A
  key-bytes-B  ; encoded key B
  ...
  key-bytes-Z] ; encoded key Z
 :merkle-db.index/children
 [link-0       ; link to subtree containing pk &lt; A
  link-1       ; link to subtree containing A &lt;= pk &lt; B
  link-2       ; link to subtree containing B &lt;= pk &lt; ...
  ...
  link-26]}    ; link to subtree containing Z &lt;= pk
</code></pre>
<h2><a href="#partitions" name="partitions"></a>Partitions</h2>
<p>Partitions hold contiguous non-overlapping ranges of records, sorted by id key. The records’ field data is stored in <em>tablets</em>, which are linked from each partition.</p>
<p>Unlike the internal nodes, partitions may contain significantly more entries than the index tree’s branching factor. When partitions grow above this limit, they are split into two smaller partitions to enable better parallelism when processing the table.</p>
<p>Tables may define <em>families</em> of fields which are often accessed together, as a storage optimization for queries. Each family of fields will be written in separate tablet in each partition, allowing queries to read from only the families whose data they require.</p>
<p>Partitions always contain at least one <em>base</em> tablet, which is used to store the data from any fields not grouped into a family. <em>All</em> record keys will be present in the base tablet, even if there is no field data present. This makes sure that the full sequence of keys can be enumerated with only the base.</p>
<pre><code class="clojure">{:data/type :merkle-db/partition
 :merkle-db.data/count Long
 :merkle-db.data/families {Keyword #{field-key}}
 :merkle-db.partition/limit Long
 :merkle-db.partition/membership BloomFilter
 :merkle-db.partition/first-key key-bytes
 :merkle-db.partition/last-key key-bytes
 :merkle-db.partition/tablets
 {:base MerkleLink
  family-key MerkleLink}}
</code></pre>
<p>Partitions store family information locally because occasionally tables may be in a transitionary state where some partitions’ family configuration does not match the desired one set in the table root.</p>
<h2><a href="#data-tablets" name="data-tablets"></a>Data Tablets</h2>
<p>The actual record data is stored in the <em>tablets</em>.</p>
<pre><code class="clojure">{:data/type :merkle-db/tablet
 :merkle-db.tablet/records
 [[key-bytes-a {:abc 123, "xyz" true, ...}]
  [key-bytes-b {:abc 456, "xyz" false, ...}]
  ...]}
</code></pre>
<p>Tablets should not link to any further nodes, and are probably the best candidate for a custom encoding format. In particular, caching field names at the beginning of the data and referencing them by number in the actual record bodies would probably save a lot of space. This may not be a huge win compared to simply applying compression to the entire tablet block, however.</p>
<h2><a href="#patch-tablets" name="patch-tablets"></a>Patch Tablets</h2>
<p>In addition to the main data tree, tables may contain a <em>patch tablet</em> linked directly from the root node. This tablet holds complete records and tombstones sorted by pk which override the main data tree. This is similar to Clojure’s <code>PersistentVector</code> tail and allows for amortizing table updates across many operations. Later, the contents of the patch tablet can be flushed together to update the main data tree.</p>
<p>Insertions and updates write new full record values to the patch tablet. This requires a read from the main data tree to fill in values, but saves tremendously on storage space. Deletions add a tombstone marker to the patch tablet so that later reads can elide the record.</p>
<p>To perform a batch read, first the patch tablet is consulted. If it contains a tombstone, the record was deleted. If it contains data, that is taken as the full record content. If any records were not found, they are read from the main data tree as normal.</p>
<p>To perform a range scan, both the data tree and the patch tablet are read with the same range criteria. In the resulting sequence, any records appearing in the patch tablet replace the values from the data tree. Tombstones will remove a record from the result if it would have been present; patch data will replace (not merge with) the data in the tree, or insert the record if it wasn’t already present.</p></div></div></div></body></html>