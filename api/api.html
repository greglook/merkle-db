<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Client API</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Merkle-db</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="api.html"><div class="inner"><span>Client API</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>Structural Design</span></div></a></li><li class="depth-1 "><a href="indexing.html"><div class="inner"><span>Index Tree Algorithms</span></div></a></li><li class="depth-1 "><a href="usage.html"><div class="inner"><span>Usage Patterns</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>merkle-db</span></div></div></li><li class="depth-2 branch"><a href="merkle-db.bloom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bloom</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.partition.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>partition</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.patch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>patch</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.record.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>record</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.tablet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tablet</span></div></a></li><li class="depth-2"><a href="merkle-db.validate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validate</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#client-api" name="client-api"></a>Client API</h1>
<p>The libraryâ€™s client interface is broken up into four main sections, dealing with the various levels of data storage.</p>
<h2><a href="#connection-operations" name="connection-operations"></a>Connection Operations</h2>
<p>A <em>connection</em> is a long-lived handle to the backing data store and db ref manager. It can be used to open databases for reading and writing.</p>
<pre><code class="clojure">; Create a new connection to a backing block store and reference manager.
; Options may include serialization, caching, and other configuration.
(conn/connect node-store ref-manager &amp; opts) =&gt; conn

; List information about the current version of each database present.
(conn/list-dbs conn opts) =&gt;
({:merkledag.node/id Multihash
  :merkle-db.db/name String
  :merkle-db.db/version Long
  :merkle-db.db/committed-at Instant}
 ...)

; List information about the version history of a specific database.
(conn/get-db-history conn db-name) =&gt; (db-version ...)

; Initialize a new database with some optional root data.
(conn/create-db! conn db-name root-data) =&gt; db

; Drop a database ref. Note that this will not remove the block data, as it
; may be shared.
(conn/drop-db! conn db-name)

; Open a database for use. An optional argument may be provided, which will
; return the last committed database version occurring before that time.
(conn/open-db conn db-name opts) =&gt; db

; Ensure all data has been written to the backing block store and update the
; database's root in the ref manager.
(conn/commit! conn db) =&gt; db'

; You can optionally commit the database under a new name, creating a virtual
; copy of the database.
(conn/commit! conn db-name db) =&gt; db'
</code></pre>
<h2><a href="#database-operations" name="database-operations"></a>Database Operations</h2>
<p>Databases provide an immutable wrapper around the dynamic connection to the block and ref stores. Once you are interacting with the database object, most operations will return a locally-updated copy but not actually change the backing storage until <code>commit!</code> is called.</p>
<p>Database values are map-like, and present both the database version attributes (<code>:merkledag.node/id</code>, <code>:merkle-db.db/name</code>, <code>:merkle-db.db/version</code>, <code>:merkle-db.db/committed-at</code>) as well as the attributes stored in the database root node.</p>
<pre><code class="clojure">; Databases provide direct keyword access to their properties:
(into {} db) =&gt;
{:merkledag.node/id Multihash
 :merkle-db.record/size Long
 :merkle-db.db/committed-at Instant
 :merkle-db.db/name String
 :merkle-db.db/version Long
 :merkle-db.db/tables {table-name MerkleLink}
 :time/updated-at Instant
 ,,,}

; Additional attributes can be associated:
(assoc db :merkle-db.key/lexicoder :string) =&gt; db'

; List information about the tables within a database.
(db/list-tables db opts) =&gt;
({:merkledag.node/id Multihash
  :merkle-db.table/name String
  :merkle-db.record/size Long}
 ...)

; Add a new table to the database. Options may include pre-defined field
; families and metadata.
(db/create-table db table-name opts) =&gt; db'

; Return a reified value representing the table.
(db/get-table db table-name) =&gt; table

; Update the named table. The function `f` will be called with the current
; table value, followed by any provided arguments. The result will be used as
; the new table.
(db/update-table db table-name f &amp; args) =&gt; db'

; Remove a table from the database.
(db/drop-table db table-name) =&gt; db'

; Flush local changes to the backing store.
(db/flush! db) =&gt; db'
</code></pre>
<h2><a href="#table-operations" name="table-operations"></a>Table Operations</h2>
<p>Tables are collections of records, identified by a string name. Each table name must be unique within the database. These operations provide a high-level interface for accessing and manipulating record data.</p>
<p>The lookup functions all take a set of <code>fields</code> to return information for. This helps reduce the amount of work done to fetch undesired data from the store. If the fields are <code>nil</code> or not provided, all record data will be returned.</p>
<pre><code class="clojure">; Read the keys of records present in the table. If start and end keys are
; given, only records within the bounds will be returned. A nil start or end
; implies the beginning or end of the data, respectively.
;
; - :min-key
; - :max-key
; - :reverse
; - :offset
; - :limit
(table/keys table opts) =&gt; (key ...)

; Scan the records in a table, returning a sequence of data for the given set of
; fields. If start and end keys or indices are given, only records within the
; bounds will be returned (inclusive). A nil start or end implies the beginning
; or end of the data, respectively.
;
; - :fields
; - :min-key
; - :max-key
; - :reverse
; - :offset
; - :limit
(table/scan table opts) =&gt; ([key record] ...)

; Read a set of records from the database, returning data for the given set of
; fields for each located record.
(table/read table record-keys opts) =&gt; ([key record] ...)

; Write a collection of records to the database, represented as a map of record
; key values to record data maps. The options may include merge resolution
; functions which control how the updates are applied.
;
; - merge-field
; - merge-record
(table/insert table records opts) =&gt; table'

; Remove a set of records from the table, identified by a collection of record
; keys.
(table/delete table record-keys) =&gt; table'
</code></pre>
<h2><a href="#partition-operations" name="partition-operations"></a>Partition Operations</h2>
<p>Partitions divide up the record keys into ranges and are the basic unit of parallelism. These operations are lower-level and intended for use by high-performance applications.</p>
<pre><code class="clojure">; List the partitions which compose the blocks of record key ranges for the
; records in the table.
(table/list-partitions table) =&gt;
({:merkledag.node/id Multihash
  :merkle-db.record/count Long
  :merkle-db.record/size Long
  :merkle-db.record/first-key key-bytes
  :merkle-db.record/last-key key-bytes}
 ...)

; Read all the records in the given partition, returning a sequence of data for
; the given set of fields.
(table/read-partition table node-id fields) =&gt; ([k record] ...)

; Add a single new partition to a table. The partition must not overlap with
; existing partitions.
(table/add-partition table partition) =&gt; table'

; Rebuild a table from a sequence of new or updated partitions. Existing table
; settings and metadata are left unchanged.
(table/rebuild table partition-ids) =&gt; table'
</code></pre></div></div></div></body></html>