<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Index Tree Algorithms</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Merkle-db</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="api.html"><div class="inner"><span>Client API</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>Structural Design</span></div></a></li><li class="depth-1  current"><a href="indexing.html"><div class="inner"><span>Index Tree Algorithms</span></div></a></li><li class="depth-1 "><a href="usage.html"><div class="inner"><span>Usage Patterns</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>merkle-db</span></div></div></li><li class="depth-2 branch"><a href="merkle-db.bloom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bloom</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.partition.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>partition</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.patch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>patch</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.record.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>record</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-2 branch"><a href="merkle-db.tablet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tablet</span></div></a></li><li class="depth-2"><a href="merkle-db.validate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validate</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#index-tree-algorithms" name="index-tree-algorithms"></a>Index Tree Algorithms</h1>
<p>Index trees are modeled after <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ trees</a> and contain both internal index nodes and leaf partitions. Records in the tree are sorted by their <em>id key</em>, which uniquely identifies each record within the table.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>There are three groups of attributes which are used in the index tree structure. At the table level, two input parameters control how the data tree is shaped:</p>
<ul>
  <li><code>:merkle-db.index/fan-out</code>  An integer which restricts the <em>maximum</em> number of children an index node can  have. In a tree with fan-out <code>f</code>, every index node except the root  must have between <code>ceiling(f/2)</code> and <code>f</code> children. The root is allowed to have  between 2 and <code>f</code> children. The fan-out must be at least 4, but is often much  higher to reduce tree height (default: 256).</li>
  <li><code>:merkle-db.partition/limit</code>  This limit restricts the maximum number of records a single partition can  hold. This effectively scales the size of the units of parallelism available  to batch jobs. In a tree with partition limit <code>p</code> every partition must contain  between <code>ceiling(p/2)</code> and <code>p</code> records, unless the root is a partition  (implying that there are fewer than <code>p</code> records total).</li>
</ul>
<p>Inside the tree, every node maintains three bookkeeping properties which define the scope of the subtree under that node:</p>
<ul>
  <li><code>:merkle-db.record/count</code></li>
  <li><code>:merkle-db.record/first-key</code></li>
  <li><code>:merkle-db.record/last-key</code></li>
</ul>
<p>Index nodes additionally use these attributes to store links and information about their children:</p>
<ul>
  <li><code>:merkle-db.index/height</code></li>
  <li><code>:merkle-db.index/keys</code></li>
  <li><code>:merkle-db.index/children</code></li>
</ul>
<h2><a href="#reading-data" name="reading-data"></a>Reading Data</h2>
<p>Record data can be read from the index tree in two fashions; a retrieval of a batch of keys for specific records, or a linear scan of some range of the data.</p>
<h3><a href="#batch-reads" name="batch-reads"></a>Batch Reads</h3>
<p>In the batch case, a simple recursive algorithm is used to divide up the keys at each node and forward them towards the child that contains the range the requested keys are in. Once a partition is reached, the records can be looked up from the tablets and returned back up the recursion stack.</p>
<h3><a href="#range-scans" name="range-scans"></a>Range Scans</h3>
<p>For scanning a range of records, the start and end keys (if provided) can be used to eliminate parts of the tree which do not contain any records in the range. The recursion continues down the first eligible child at each level until it reaches a partition, at which point the records are scanned out starting from the first valid key. This can be modeled as a lazy sequence which only expands a node once the first record from that subtree is requested.</p>
<h2><a href="#updating-data" name="updating-data"></a>Updating Data</h2>
<p>Updating an index tree starts with the root node and a batch of changes to apply to it. The changes may be either insertions supplying new field data for a certain record key or deletions which remove a record.</p>
<p>The batch-update algorithm has the following goals:</p>
<ul>
  <li><strong>Log scaling:</strong> visit <code>O(log_b(n))</code> nodes for <code>n</code> partitions updated.</li>
  <li><strong>Minimize garbage:</strong> avoid storing nodes which are not part of the final  tree.</li>
  <li><strong>Deduplication:</strong> reuse existing stored nodes where possible.</li>
</ul>
<p>Note that the first and third points here also imply that an update <em>should not</em> rewrite nodes that are not being changed if they no longer match the tree parameters. For example, changing the fanout from 4 to 6 means that any index nodes with only two children are no longer valid. An update which doesn’t touch those nodes would leave them in the tree as-is for a later process to fix-up.</p>
<h3><a href="#empty-tree" name="empty-tree"></a>Empty Tree</h3>
<p>In the simplest case, we are updating an empty index tree. This is represented by a nil tree root.</p>
<ol>
  <li>Filter out the tombstone changes, since there’s nothing to delete.</li>
  <li>Divide up the additions into valid partition-sized chunks.</li>
  <li>Serialize out a partition for each chunk.</li>
  <li>If there are multiple partitions, build an index tree containing them.</li>
</ol>
<h3><a href="#single-partition" name="single-partition"></a>Single Partition</h3>
<p>If the tree has fewer than <code>:merkle-db.partition/limit</code> records in it, the tree will have a single partition node as the root. To update it:</p>
<ol>
  <li>Read the full records from the partition.</li>
  <li>Remove any deleted records.</li>
  <li>Insert the added records, replacing any existing data.</li>
  <li>If the updated partition is valid, store it and return the node.</li>
  <li>If the resulting partition would overflow, divide the records into roughly  equally sized partitions and build an index from them.</li>
</ol>
<h3><a href="#index-updates" name="index-updates"></a>Index Updates</h3>
<p>In the general case, there is a tree of existing nodes including one or more layers of intermediate index nodes and a collection of partition leaves. The tree must be carefully updated to preserve the structural parameters. Unlike a regular B+ tree, which can be extended to batches of inserts or deletes, here we want to perform batch updates which include <em>both</em> updates and deletes. This means that some nodes in the tree may need to split while other parts need to merge, and we need to reconcile these while changing as few nodes as possible.</p>
<p>To understand how this is accomplished, let’s consider the update to a generic individual index node in the tree. What would such a function look like? For inputs, first we’ll need the graph store (so we can store and retrieve nodes) and a set of tree-level parameters specifying the fan-out, partition limit, and field families. We will assume these as a given throughout the algorithm.</p>
<p>Next we’ll need the data for the node we’re operating on, and the sequence of changes to apply to it. Generally, the changes should fall into the range of record keys that the index subtree covers. Finally, we’ll accept a <em>carry</em> input, which will be explained later.</p>
<p>Initially, the obvious choice for an output is the updated version of the input node. However, this fails to account for the fact that we may need to split the node if there are many additions, or merge it if there are many deletions. Instead, the function will return a <em>vector</em> of nodes, along with an integer specifying the height of the results. If we input an index node <code>n</code> at height <code>h</code> and had no splits or merges, we’d expect to get the result <code>[h [n']]</code>.</p>
<h4><a href="#divide-changes" name="divide-changes"></a>Divide Changes</h4>
<p>The first thing to do is to take the set of input record changes and divide them up according to which child subtree they belong to. Each index node maintains a list of child links and split keys, so portion out the changes to bucket them by record key.</p>
<p>The result is a sequence of tuples containing the child and a vector of the record changes assigned to that child. Children with no changes will appear with a nil second value.</p>
<h4><a href="#carry-adoption" name="carry-adoption"></a>Carry Adoption</h4>
<p>The next thing to consider is whether the update to this node has a carried input. If so, we need to determine whether to adopt the carried elements as children of the current node or keep carrying them down the subtree. Since carried inputs have the same form as an update result vector, we can check whether the height of the carry is one less than the height of the current node.</p>
<p>If so, adopt the elements as children of the current node by prepending them to the sequence of children and changes as nodes with no changes (as they have already been applied earlier).</p>
<p>If there is a carried input that is <em>not</em> adoptable because it falls deeper in the tree than the current node, save it as the first carried input into the sequence of children.</p>
<p>If there is no carried input, there’s nothing to do.</p>
<h4><a href="#update-children" name="update-children"></a>Update Children</h4>
<p>Begin a loop to build up a new vector of updated child nodes. Recurse into the first child, using the carry if present. Examine the result - if the height is the same as the original child, add the elements to the output vector. Otherwise, carry the result into the update on the next child.</p>
<p>After processing all of the original children, there are four possible scenarios: - There are no output children and no final carry. All the records in the  subtree have been removed, so return nil. - There are no output children and a final carry. Return the carry output for  further carrying up the tree. - There are outputs and no carry. This is the simplest case, and we can just  use the output children directly. - There are both outputs and a carry. In this case we need to <em>carry back</em> the  result and merge it into the last node in the output vector.</p>
<p>In the first two cases we are done with the update to this node and can return the result. In the latter two we have further processing to do. For carry-backs, we need to re-run update logic on the final output child. The result will either be an updated set of direct children or another carry output, in which case the process repeats until the results are valid or we’re reduced back to a carry output.</p>
<h4><a href="#update-partitions" name="update-partitions"></a>Update Partitions</h4>
<p>Updating partitions actually requires loading data into memory, so the algorithm constrains the total number of partitions loaded to double the partition limit <code>p</code>. Updated sets of records are buffered as the children are processed, emitting full partitions where possible, merging in underflowing partitions as needed. The buffer is filled until at least 150% of the partition limit has been reached, then a 75% full partition is emitted, leaving (at worst) another 75% full partition if there are no more adjacent to process.</p>
<h4><a href="#rebuild-indexes" name="rebuild-indexes"></a>Rebuild Indexes</h4>
<p>If the result was a sequence of updated (direct) children, then we can now construct a new index node to contain them. Compare the number of children available to the tree’s fan-out - if there are not enough children to make a valid half-full node, return the vector of children for carrying. Otherwise divide the children into valid-sized branching groups and build index nodes to contain them.</p>
<p>At this point we’ve completed the update algorithm for a single node, the result of which was either a sequence of one or more index nodes at the original level, or a sequence of sibling nodes carried up from further down the tree.</p>
<h4><a href="#promote-root" name="promote-root"></a>Promote Root</h4>
<p>After recursively applying changes to the root node and unwinding back to the top of the tree, examine the result.</p>
<ul>
  <li>If it is nil, the tree was entirely deleted.</li>
  <li>If the result height is negative, we have a sequence of records and must make  an underflowing partition to hold them as the root node.</li>
  <li>If the result has a single node in it, that is the new root of the tree.</li>
  <li>If it has multiple nodes, the tree root split at some point and we must build  new layers of index nodes until there is a single root node.</li>
</ul>
<h2><a href="#references" name="references"></a>References</h2>
<ul>
  <li><a href="https://pdfs.semanticscholar.org/85eb/4cf8dfd51708418881e2b5356d6778645a1a.pdf">https://pdfs.semanticscholar.org/85eb/4cf8dfd51708418881e2b5356d6778645a1a.pdf</a>  Insight: instead of flushing all the updates, select a related subgroup that  minimizes repeated changes to the same node path.</li>
  <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.7269&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.7269&amp;rep=rep1&amp;type=pdf</a>  Modern B-Tree Techniques</li>
</ul></div></div></div></body></html>